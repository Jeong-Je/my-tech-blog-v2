---
title: "토렌트(torrent) 시스템의 원리"
date: 2024-11-08
tags:
- etc
description: P2P 통신을 이용한 토렌트 파일 다운로드 원리
---
![bittorrent](/images/post-35/bittorrent.svg)

그 유명한 **BitTorrent**는 `P2P` 방식을 통해서 파일 공유한다.

## P2P 방식

대부분의 서비스(네이버, 게임 등)는 **서버/클라이언트** 방식을 이용하는데 **P2P**는 서버로 부터 데이터를 받는 구조가 아니다.

서버/클라이언트는 모든 요청이 서버를 경유하므로 서버의 부담이 크고 **DDOS** 공격의 위험도 있다.

**P2P**는 서버를 배치하지 않고 클라이언트끼리 통신을 한다.

## 토렌트 시스템

**P2P**를 이용하여 파일을 클라이언트끼리 공유하는 토렌트 시스템이 나왔고 전세계 네트워크 트래픽의 상당히 많은 부분을 차지할 정도로 이용자가 많다.

### 토렌트의 작동 구조

- **리치**: .torrent 파일을 가지고 다운로드 받는 클라이언트 
- **시드**: 리치한테 파일의 조각을 보내주는 피어
- **트래커**: 리치에서 시드들의 주소를 알려주는 중계자 역할

리치가 파일을 완전히 다운로드 받으면 리치도 시드로 변한다. 

새로운 리치가 트래커한테 파일 다운로드를 요청하면

트래커는 여러 개의 시드의 주소를 리치한테 보내준다.

리치는 여러 개의 시드로부터 파일을 다운로드 받는다.

### Choke Algorithm

토렌트를 이용하면 다운로드를 하면서 자신도 배포자가 되므로 컴퓨터 자원을 나도 모르게 소모하게된다.

그래서 리치의 입장에서 파일을 다운받고 시드가 되지 않도록 다운 즉시 토렌트를 삭제하는 이용자가 많다.

토렌트는 이런 먹튀(?) 유저에게 패널티를 부여하기 위한 [Choke Algorithm](https://arpit.substack.com/p/the-choke-algorithm-that-powers-bittorrent)을 이용한다.

**A**가 **B**를 `choke`했다는 의미는 **A**가 **B**로 부터 데이터를 여전히 받을 수 있지만 데이터를 보내는 것은 하지 않는 상황이다. 

**B**가 **A**한테 다시 파일을 받을 수 있는 상태가 되면 **B**가 **A**로부터 **Unchoke**되었다고 말한다.

**피어C**가 또 다른 모든 **peer**를 **unchoke**를 한다면 모든 피어가 C로부터 데이터를 가져가려 할 것이다. 이는 C에게 너무 부담되는 상황이다.

그래서 **C**는 어떤 피어를  먼저 **unchoke**하여 데이터를 보낼 지 우선순위를 메겨야한다.

이 **우선순위**는 나한테 많은 데이터를 보내주는 피어에게 나도 더 많은 데이터를 주겠다는 원칙을 따른다.

그러므로 업로드를 하지 않는 먹튀 유저는 다운로드에서 우선 순위가 뒤로 밀려 다운 속도가 느려진다.

이를 통해 토렌트는 모든 유저들이 데이터 공유에 협조하도록 유도하지만 컴퓨터 자원 소모 문제에서 유저는 시드가 되는 것을 꺼려하는 것은 사실이다.

### 토렌트 파일의 구조

`.torrent` 파일에는 여러 정보(name, length, piece length 등)가 담겨 있지만 

제일 중요한 정보는 `트래커의 주소` 이다. 

파일을 다운 받고자 하는 유저는 트래커로부터 시드들의 주소를 받고 여러 시드로부터 파일을 다운 받는다.

***